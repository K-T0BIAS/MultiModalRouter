{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multi Modal Router","text":"<p>The Multi Modal Router is a graph-based routing engine that allows you to build and query any hub-based network. It supports multiple transport modes like driving, flying, or shipping, and lets you optimize routes by distance, time, or custom metrics. It can be expanded to any n-dimensional space making it versatile in any coordinate space</p> <p>NOTE: This project is a work in progress and features might be added and or changed</p>"},{"location":"#in-depth-documentation","title":"In depth Documentation","text":"<p>installation guide</p> <p>graph module documentation</p> <p>command line interface documentation</p> <p>utilities documentation</p> <p>code example can be found in <code>docs/examples/</code></p>"},{"location":"#features","title":"Features","text":""},{"location":"#building-freedom-unlimited-usecases","title":"Building Freedom / Unlimited Usecases","text":"<p>The graph can be build from any data aslong as the required fields are present (example). Whether your data contains real world places or you are working in a more abstract spaces with special coordinates and distance metrics the graph will behave the same (with minor limitations due to dynamic distance calculation, but not a problem when distances are already precomputed. solutions).</p>"},{"location":"#example-usecases","title":"Example Usecases","text":"<ul> <li> <p>real world flight router</p> <ul> <li>uses data with real flight data and actuall airport coordinates</li> <li>builds a graph with <code>airport</code> Hubs</li> <li>connects <code>airports</code> based on flight routes</li> <li><code>finds</code> the <code>shortest flights</code> or <code>multi leg routes</code> to get from <code>A</code> to <code>B</code></li> <li>simple example implementation here</li> </ul> </li> <li> <p>social relation ship graph</p> <ul> <li>uses user data like a social network where users are connected through others via a group of other users</li> <li>builds a graph with <code>users</code> as Hubs</li> <li>connects users based on know interactions or any other connection meric</li> <li><code>finds</code> users that are likely to <code>share</code>; <code>interests</code>, <code>friends</code>, <code>a social circle</code>, etc.</li> </ul> </li> <li> <p>coordinate based game AI and pathfinding</p> <ul> <li>uses a predefined path network (e.g. a simple maze)</li> <li><code>builds</code> the garph representation of the network</li> <li><code>finds</code> the shortest way to get from any point <code>A</code> to any other point <code>B</code> in the network</li> <li>you can checkout a simple example implementation for a maze pathfinder here</li> </ul> </li> </ul> <p></p>"},{"location":"#graph-visualizations","title":"graph visualizations","text":"<p>Use the build-in visualization tool to plot any <code>2D</code> or <code>3D</code> Graph.</p> <p></p>"},{"location":"#important-considerations-for-your-usecase","title":"Important considerations for your usecase","text":"<p>Depending on your usecase and datasets some features may not be usable see solutions below</p>"},{"location":"#potential-problems-based-on-use-case","title":"potential problems based on use case","text":"<p>Please check your data for the following</p> distance present coordinate format unusable features special considerations YES degrees None None YES not degrees runtime distance calculations set drivingEnabled = False or do this NO degrees None distances must be calculated when preprocessing NO not degrees ALL You can't build the graph with neither distances or supported coordinates! SOLUTION <p>example dataframe with the required fields</p> <p>LICENSE</p> <p>dependencies</p>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2025 Tobias Karusseit</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"NOTICE/","title":"Dependencies and Licenses","text":"<p>This project <code>MultiModalRouter</code> depends on the following libraries. All licenses are permissive and compatible with MIT licensing for this project.  </p> Package Version License License Link colorama &gt;=0.4.6 BSD 3-Clause License dill &gt;=0.4.0 BSD License filelock &gt;=3.19.1 MIT License fsspec &gt;=2025.9.0 Apache 2.0 License Jinja2 &gt;=3.1.6 BSD-3-Clause License MarkupSafe &gt;=3.0.2 BSD-3-Clause License mpmath &gt;=1.3.0 BSD License networkx &gt;=3.5 BSD License numpy &gt;=2.3.3 BSD License pandas &gt;=2.3.2 BSD-3-Clause License parquet &gt;=1.3.1 Apache 2.0 License ply &gt;=3.11 BSD License pyarrow &gt;=21.0.0 Apache 2.0 License python-dateutil &gt;=2.9.0.post0 BSD License pytz &gt;=2025.2 MIT License setuptools &gt;=80.9.0 MIT License six &gt;=1.17.0 MIT License sympy &gt;=1.14.0 BSD License thriftpy2 &gt;=0.5.3 MIT License tqdm &gt;=4.67.1 MPL 2.0 License typing_extensions &gt;=4.15.0 PSF License tzdata &gt;=2025.2 Public Domain License"},{"location":"NOTICE/#optional-dependencies","title":"Optional Dependencies","text":"Package Version License License Link torch &gt;=2.8.0 BSD License plotly &gt;=6.3.0 MIT License pytest &gt;=8.0 MIT License"},{"location":"NOTICE/#notes","title":"Notes","text":"<ol> <li>All packages listed above are permissively licensed (MIT, BSD, Apache 2.0, or Public Domain), so they are compatible with MIT licensing for this project.  </li> <li>If distributing this library, include this <code>DEPENDENCIES.md</code> file and your own MIT license file to give proper attribution.  </li> <li>Optional dependencies should be listed in documentation or <code>pyproject.toml</code> extras.  </li> </ol>"},{"location":"cli/","title":"Command Line Interface","text":"<p>HOME</p>"},{"location":"cli/#command-line-interface","title":"command line interface","text":"<p>If you don't want to always write new scripts to build the graph or to find routes, you can simply use the command line interface.</p>"},{"location":"cli/#building-a-graph-from-the-terminal","title":"building a graph from the terminal","text":"<p>this assumes that your data has been preprocessed into the correct format</p> <p>from your terminal run:</p> <pre><code>multimodalrouter-build hubType1 transportMode1 pathToDataset1 --maxDist 123 --extraMetrics metric1 metric2 --drivingEnabled --Dir pathToSomeDir\n</code></pre>"},{"location":"cli/#args","title":"args","text":"<ul> <li><code>hub type</code>,<code>transport mode</code>,<code>dataset path</code> = the first arguments in your cli should be these three. They must follow this order to be parsed correctly<ul> <li><code>hub type</code> = the name the hubs from this dataset will get</li> <li><code>transport mode</code> = the mode of transport unique to this hub</li> <li><code>dataset path</code> = ideally the absolute path to the dataset that contains this <code>hub type</code></li> <li>NOTE: you can add as many hub types and datasets at once as you want just make sure the order is always; type1 mode1 path1 type2 ...</li> </ul> </li> <li><code>--maxDist</code> = the float value that limits the maximum length a driving edge can have (this is irrelevant id <code>--enableDriving</code> isn't set)</li> <li><code>extraMetrics</code> = a list of keys that the graph will scan your data for and add the values to any edge where the key exists in the data (NOTE: each key should be present in at least one dataset, the number of extra metrics is not limited)</li> <li><code>--drivingEnabled</code> = if this flag is added the graph will try to build connections between hubs for any hub that is closer than the <code>--maxDist</code> to anoter hub (check here to see if your data allows this)</li> <li><code>--Dir</code> = put the target directory of the save file here. (if this is not set the graph will be saved to a default dir)</li> </ul>"},{"location":"cli/#example","title":"example","text":"<p>create a new dir for the garph and edit the <code>--Dir</code> if you want the graph in a easy to access directory otherwise keep as is</p> <p>NOTE: this example assumes you are still in the project dir. If not please adapt the dataset path accordingly</p> <pre><code>multimodalrouter-build airport plane ./docs/examples/flightRouter/data/fullDataset.csv --maxDist 100 --drivingEnabled \n--extraMetrics source_name destination_name\n</code></pre> <p>output:</p> <pre><code>Building graph...\nGenerating airport Hubs: 100hub [00:00, 186995.27hub/s]\nGraph built and saved.\n</code></pre>"},{"location":"cli/#finding-a-route","title":"finding a route","text":"<pre><code>multimodalrouter-route --start lat1 lng1 --end lat2 lng2 --allowedModes car plane --maxSegments 123 --verbose\n</code></pre> <p>NOTE: if you have higher dimensional coordinates you can simply add them here aswell</p>"},{"location":"cli/#agrs","title":"agrs","text":"<ul> <li><code>--start</code> = the start coordinates for the route (doesn't have to be exact to the <code>Hub</code> it will find the closest hub to the point. Also the coordinates do not have to be in dgrees, but rather fit with the coordinate system of your data. Read more here)</li> <li><code>--end</code> = the end coordinates of the route: (same features as for <code>--start</code> apply)</li> <li><code>--allowedModes</code> = a filter that discards edges that use a transport mode that is not in this list. (default= ['car'])</li> <li><code>--maxSegments</code> = an interger value of the maximum number of hubs a route can have. (e.g.: to avoid very deep searches when long routes are not logically feasable) (default = 10)</li> <li><code>--verbose</code> = if this flag is set the output route will contain the edgeMetadata for every leg of the route (default=false when flag not set)</li> </ul>"},{"location":"cli/#example_1","title":"example","text":"<p>NOTE: this example assumes you build the graph from the previous example. if you changed the save path this script wont find it (this will hopefully be fixed in the future).</p> <pre><code>multimodalrouter-route --start 60.866699 -162.272996 --end 60.872747 -162.5247 --allowedModes plane car --maxSegments 10 --verbose\n</code></pre> <p>output:</p> <pre><code>Start: ATT\n        Edge: (transportMode=plane, metrics={'distance': 13.641155702721523, 'source_name': 'Atmautluak Airport', 'destination_name': 'Kasigluk Airport'})\n-&gt; KUK\n</code></pre>"},{"location":"graph/","title":"Graph","text":"<p>HOME</p> <p>graph</p> <ul> <li>advanced options<ul> <li>custom distance metrics</li> <li>higher dimensional graphs</li> </ul> </li> </ul> <p>dataclasses</p> <p>Hub</p> <p>EdgeMetadata</p> <p>Route</p>"},{"location":"graph/#routegraph","title":"RouteGraph","text":"<p>The <code>RouteGraph</code> is the central class of the package implemented as a dynamic (cyclic) directed graph. It defines all graph building and routing related functions.</p>"},{"location":"graph/#functionality","title":"Functionality","text":""},{"location":"graph/#initialization","title":"initialization","text":"<p>This creates a new graph with no <code>Hubs</code> or <code>Edges</code>.</p> <pre><code>def __init__(\n    self, \n    maxDistance: float,\n    transportModes: dict[str, str],\n    dataPaths: dict[str, str] = {},\n    compressed: bool = False,\n    extraMetricsKeys: list[str] = [],\n    drivingEnabled: bool = True,\n    sourceCoordKeys: list[str] = [\"source_lat\", \"source_lng\"],\n    destCoordKeys: list[str] = [\"destination_lat\", \"destination_lng\"],\n):\n</code></pre>"},{"location":"graph/#args","title":"args","text":"<p>Terminology:</p> <p>Hub Type: hub types are the user defined names for their hubs. e.g. when having data for flights you have <code>airports</code>, thus you may want to define the hubs for the airports as type <code>airport</code>. (Hub Types can be anything you want to name them) </p> <ul> <li><code>maxDistance</code>: float = The maximum distance a driving edge is allowed to span</li> <li><code>transportModes</code>: dict[str, str] = a dictionary that assigns Hub Types to their mode of travel. E.g. </li> </ul> <pre><code>transportModes = {\n    'airport': 'fly',# here hub type airport is assigned its primary mode of travel as fly\n}\n</code></pre> <ul> <li><code>dataPaths</code>: dict[str, str] = a dictionary that stores the paths to datasets realtive to their Hub Types. E.g.:</li> </ul> <pre><code>dataPaths = {\n    # hub type: path to dataset\n    'airport': '~/MUltiModalRouter/data/AirportDataset.parquet'\n}\n</code></pre> <ul> <li><code>compressed</code>: bool = wheter to save this graph in compressed files or not (NOTE: this is not used at the moment so just skip)</li> <li><code>extraMetricsKeys</code>: list[str] = a list of metrics the graph will search for in the datasets when building edges (NOTE: default metrics must still be present) Example:</li> </ul> <pre><code># given at least one dataset with the col 'time'\n\nextraMetricsKeys = ['time']\n</code></pre> <p>When the graph finds this key in a dataset it will then add this metric (here <code>time</code>) to all edges that come from hubs stored inside this dataset</p> <ul> <li><code>drivingEnabled</code>: bool = whether the graph should connect all possible hubs that have distance(a,b) \\leq maxDistance (default=True)</li> <li><code>sourecCoordKeys</code>: list[str] = a list of keys from your data that contains the column names from your source coordinates. (NOTE: if you have more than one dataset you can just put all source keys into this list as long as the same keys arent for any other metric somewhere else)</li> <li><code>destCoordKeys</code>: list[str] = a list of keys from your data that contains the column names of the destination coordinates. (same conditions as for source apply)</li> </ul> <p>NOTE: the source and dest coord keys are matched to the correct datasets automatically you can just bundle them all together in one list</p>"},{"location":"graph/#example","title":"example","text":"<p>Init a graph with Hubs: <code>airport</code>, <code>trainstation</code></p> <pre><code>from multimodalrouter import RouteGraph\n\ngraph = RouteGraph(\n    maxDistance = 50,\n    transportModes = {\n        'airport': 'plane',\n        'trainstation': 'train'\n    },\n    dataPaths = {\n        'airport': pathToAirportData,\n        'trainstation': pathToTrainData\n    }\n    # time and cost must each be present in at least one dataset\n    extraMetricsKeys = ['time', 'cost'], \n    # default is True so this is not necessary \n    drivingEnabled = True, \n)\n</code></pre> <p>The resulting graph will be able to build <code>HUbs</code> for both <code>train stations</code> and <code>airports</code>. It will also use the extra metrics in all edges where the data is present</p>"},{"location":"graph/#build","title":"build","text":"<p>After a graph is initialized it doesn't contain any actual nodes or edges yet. To create the nodes and edges the graph has to be build.</p> <pre><code>def build(self):\n</code></pre>"},{"location":"graph/#example_1","title":"example","text":"<p>click here to see how to init the graph</p> <pre><code># with the graph from the previous example\n\ngraph.build()\n</code></pre> <p>After this finishes the graph is build and ready for routing</p>"},{"location":"graph/#routing-finding-the-shortest-path-form-a-to-b","title":"routing / finding the shortest Path form A to B","text":"<pre><code>def find_shortest_path(\n    self, \n    start_id: str, \n    end_id: str, \n    allowed_modes: list[str],\n    optimization_metric: OptimizationMetric | str = OptimizationMetric.DISTANCE,\n    max_segments: int = 10,\n    verbose: bool = False\n    ) -&gt; Route | None:\n</code></pre>"},{"location":"graph/#args_1","title":"args","text":"<ul> <li>start_id: str = the Hub.id of the starting hub (e.g. the source field for this hub in your data -&gt; for <code>airports</code> likely the iata code) (for coordinate searches see here)</li> <li>end_id: str = the Hub.id of the traget Hub</li> <li>allowed_modes: list[str] = a list of transport modes that are allowed in the path (all edges with different modes are excluded)(The modes are set during the graph initailization)</li> <li>optimization_metric: str = the metric by which the pathfinder will determine the length of the path (must be numeric and present in all searched edges) (default = <code>distance</code>) (metrics where also set during initialization)</li> <li>max_segments: int = the maximum number of hubs the route is allowed to include (default = 10 to avoid massive searches but should be setvrealtive to the graph size and density)</li> <li>verbose: bool = whether you want to store all edges and their data in the route or just the hub names (default=False)</li> </ul> <p>returns : Route or None if no route was found</p>"},{"location":"graph/#radial-search-finding-all-hubs-inside-a-radius","title":"radial search /finding all hubs inside a radius","text":"<p>Note: this doesn't search a direct radius but rather a reachablity distance (e.g.: A and B may have a distance x \\leq r, but the shortest connecting path has distance y \\geq r)</p> <pre><code>def radial_search(\n    self,\n    hub_id: str,\n    radius: float,\n    optimization_metric: OptimizationMetric | str = OptimizationMetric.DISTANCE,\n    allowed_modes: list[str] = None,\n    custom_filter: Filter = None\n) -&gt; list[float, Hub]:\n</code></pre>"},{"location":"graph/#args_2","title":"args","text":"<ul> <li><code>hub_id</code>: str = the id of the center hub the search starts at</li> <li><code>radius</code>: float = the maximum value the search metric is allowed to have from the start</li> <li><code>optimization_metric</code>: str = the target metric you want to use for the distance (default='distance')</li> <li><code>allowed_modes</code>: list[str] = the types of edges that are considered (default= None =&gt; all edges are checked)</li> <li><code>custom_filter</code>: Filter = a filter object you can pass to add filters for Hubs and edgeMetadata</li> </ul> <p>returns: list[ tuple[float, Hub] ] = a list of all reachable hubs with the 'distance' to the start</p>"},{"location":"graph/#save","title":"save","text":"<pre><code>def save(\n    self, \n    filepath: str = os.path.join(os.getcwd(), \"..\", \"..\", \"..\", \"data\"), \n    compressed: bool = False):\n</code></pre> <p>The <code>save</code> method will create a save file from the last garph state. Depending on the <code>arguments</code> the file will either be stored as <code>.dill</code> or <code>.zlib</code>. A save file contains the complete statedict of the RouteGraph instance except attributes that could break the pickling process (e.g. <code>threading.Lock</code>).</p>"},{"location":"graph/#args_3","title":"args","text":"<ul> <li>filepath: str = the directory that the savefile will be stored in (defaults to <code>MultiModalRouter/data</code>)</li> <li>compressed: bool = whether to compress the output into <code>.zlib</code> or store as <code>.dill</code></li> </ul>"},{"location":"graph/#example_2","title":"example","text":"<p>Saving a graph to a custom dir, in a <code>.dill</code> file</p> <pre><code>...\ngraph.save(filepath=customDir)\n</code></pre>"},{"location":"graph/#load","title":"load","text":"<pre><code>@staticmethod\ndef load(\n    filepath: str, \n    compressed: bool = False\n) -&gt; \"RouteGraph\":\n</code></pre> <p>The load method is a static method that allows you to load a graph from its save file into a new graph object. The resulting graph object is fully initialized and can be used as is.</p>"},{"location":"graph/#args_4","title":"args","text":"<ul> <li>filepath: str = the full path to your save file </li> <li>compressed: bool = set this to <code>True</code> if your graph was saved to a <code>.zlib</code> compressed file (default=<code>False</code>)</li> </ul>"},{"location":"graph/#example_3","title":"example","text":"<pre><code>from multimodalrouter import RouteGraph\n# load a .dill file from 'pathToMyGraph'\nmyGraph = RouteGraph.load(filepath=pathToMyGraph) \n</code></pre> <p>The <code>myGraph</code> object is now fully loaded and can be used to its full extend.</p>"},{"location":"graph/#searching-with-coordinates","title":"searching with coordinates","text":"<p>Since searching by hub id is not always possible the graph has a helper that finds a hub closest to a coordinate tuple.</p> <pre><code>def findClosestHub(\n    self, \n    allowedHubTypes: list[str], \n    coords: list[float],\n) -&gt; Hub | None:\n</code></pre>"},{"location":"graph/#args_5","title":"args","text":"<ul> <li>allowedHubTypes: list[str] = a list that defines which hubs should be searched (e.g. ['airport','trainstation']) NOTE: if you set this to <code>None</code> all hubs will be included in  the search</li> <li>coords: list[float] = the coordinates of the hub. (not limited to 2 dimensions)</li> </ul> <p>NOTE: the coords must not necessarily be in degrees or any other meaningfull metric aslong as your data provides distances and you turn of enableDrive when building the graph or you do this</p> <p>NOTE: it is entirely possible to setup the graph with custom coordinate systems and distances</p>"},{"location":"graph/#example_4","title":"example","text":"<pre><code>coordinates = 100.0, 100.0\nclosestHub = graph.findClosestHub(\n    allowedHUbTypes = None, # include all types in search\n    *coordinates, \n)\n</code></pre> <p>NOTE: you can now use <code>closestHub.id</code> in the search</p>"},{"location":"graph/#getting-hubs-by-id","title":"getting hubs by id","text":"<p>If you want to inspect a hub and you know its <code>id</code> you can get it from the graph as follows</p> <pre><code>def getHub(\n    self, \n    hubType: str, \n    id: str\n) -&gt; Hub | None:\n</code></pre> <p>or </p> <pre><code>def getHubById(\n    self, \n    id: str\n) -&gt; Hub | None:\n</code></pre>"},{"location":"graph/#args_6","title":"args","text":"<ul> <li>hubType: str = the type of the target hub</li> <li>id: str = the id of the target hub</li> </ul> <p>returns: the Hub or if not found None</p>"},{"location":"graph/#manually-adding-hubs","title":"manually adding Hubs","text":"<p>If you want to add a new Hub to a graph without building use this:</p> <pre><code>def addHub(self, hub: Hub):\n</code></pre> <p>This will add your Hub to the garph and if its already present it will fail silently</p>"},{"location":"graph/#args_7","title":"args","text":"<ul> <li>hub: Hub = the Hub you want to add</li> </ul>"},{"location":"graph/#-","title":"---","text":""},{"location":"graph/#advanced-options","title":"advanced options","text":""},{"location":"graph/#swap-distance-method","title":"swap distance method","text":"<p>When your dataset comes with neither distances nor a coordinate system in degrees you can mount your own distance function. This way you will still be able to build the default driving edges etc.</p>"},{"location":"graph/#example_5","title":"example","text":"<pre><code>from multimodalrouter import RouteGraph\nimport types\n# define your own distance metric (NOTE the arguments must be the same as here)\ndef myDistancMetric(self, hub1: list[Hub], hub2: list[Hub]):\n    ... # here you could for example calculate the euclidean distance\n    return distances # np.array or list\n\n# create a normal graph object \nspecialGraph = RouteGraph(**kwargs)\n# swap the distance method\nspecialGraph._hubToHubDistances = types.MethodType(myDistanceMetric, specialGraph)\n# continue as you would normally\ngraph.build()\n</code></pre>"},{"location":"graph/#notes","title":"NOTES","text":"<ul> <li>Naturally you can do the same thing for the preprocessor to calculate the transport mode based distances in the preprocessessing step.</li> </ul>"},{"location":"graph/#higher-dimensional-graphs","title":"higher dimensional graphs","text":"<p>To build graphs from higher dimensional data a few things have to be done differently. As an example I will use the following datasets</p> source destination sdim1 sdim2 sdim3 ddim1 ddim2 ddim3 distance A B 0 0 0 1 2 2 3 C A 2 4 4 0 0 0 6 B C 1 2 2 2 4 4 3 source destination adim1 adim2 adim3 bdim1 bdim2 bdim3 distance a b 0 0 0 3 4 0 5 a c 0 0 0 0 4 0 4 c b 0 4 0 3 4 0 3 <p>With these tow 3D datasets you can build a graph as follows:</p> <pre><code>sourceKeys = ['sdim1', 'sdim2', 'sdim3', 'adim1', 'adim2', 'adim3']\ndestinationKexs = ['ddim2', 'ddim2', 'ddim3', 'bdim1', 'bdim2', 'bdim3']\n\nfrom multimodalrouter import RouteGraph\n\n# create a graph\n\nnDimGraph = RouteGraph(\n    maxDistance = 3,\n    transportModes = {\n        'T1': 'mode1',\n        'T2': 'mode2'\n    },\n    dataPaths = {\n        'T1': path1, # path to the data from 1st table\n        'T2': path2 # path to the data from 2nd table\n    },\n    drivingEnabled = False, # add your own driving func to enable this\n    sourceCoordKeys = sourceKeys, # the keys from the sources\n    destCoordKeys = destinationKeys, # the kexs from the destinations\n)\n</code></pre> <p>Now everything else works as normal but with three coordinates </p>"},{"location":"graph/#notes_1","title":"Notes:","text":"<p>To enable driving add your own distance function like this</p> <p>It is theoretically possible to combine hubs from differnt dimensions as long as a distance metric is given or the distance is pre calculated</p>"},{"location":"graph/#custom-filters-in-searches","title":"custom filters in searches","text":"<p>To add custom rulesets to searches like <code>find_shortest_path</code> you can add your own <code>Filter</code> objects</p>"},{"location":"graph/#example_6","title":"example","text":"<p>Imagine one of your datasets has the following keys</p> <pre><code>source, destination, distance, cost, sx, sy, dx, dy, namex, namey\n</code></pre> <p>You have now build your graph with the extra keys: <code>cost</code>, <code>namex</code>,<code>namey</code>, and you want to start a shortest path search that excludes edges where <code>cost</code> &gt; <code>C</code> and the where the destination <code>namey</code> = <code>N</code>. Additionally you want to exclude a list of <code>hub Ids</code> = <code>I</code></p> <p>create Filter:</p> <pre><code>from multimodalrouter import Filter\n\nclass CustomFilter(Filter):\n\n    def __init__(self, C: float, N: str, I: list[str]):\n        self.C = C\n        self.N = N\n        self.I = I\n\n    def filterHub(self, hub: Hub):\n        return hub.id not in self.I\n\n    def filterEdge(self, edge: EdgeMetadata):\n        return (edge.getMetric('cost') &lt; self.C \n                and egde-getMetric('namey') != self.N\n               )\n</code></pre> <p>use filter</p> <pre><code># graph creation code here\n\nroute = graph.find_shortest_path(\n    **kwargs,\n    custom_filter=CustomFilter(c, n, i) # your filter instance\n)\n</code></pre>"},{"location":"graph/#-_1","title":"---","text":""},{"location":"graph/#dataclasses","title":"Dataclasses","text":""},{"location":"graph/#hub","title":"Hub","text":"<p>Hubs are the nodes of the RouteGraph and store all outgoing connections alongside the relevant EdgeMetadata</p> <pre><code>def __init__(\n    self, \n    coords: list[float], \n    id: str, \n    hubType: str\n):\n</code></pre>"},{"location":"graph/#fields","title":"fields","text":"<ul> <li>coords: list[float]: the coordinates of the <code>Hub</code>. (NOTE: this can be any ndim coordinate aslong as it fits with the rest)</li> <li>id: str = a string id like iata code UNLOCODE or whatever you want (NOTE: must be unique for the hubType)</li> <li>hubType: str = the type of hub this will be (e.g. <code>airport</code>, <code>trainstation</code>,...)</li> </ul>"},{"location":"graph/#adding-edges","title":"adding edges","text":"<pre><code>def addOutgoing(\n    self, \n    mode: str, \n    dest_id: str, \n    metrics: EdgeMetadata):\n</code></pre>"},{"location":"graph/#args_8","title":"args","text":"<ul> <li>mode: str = the mode of transport along this edge (e.g. <code>plane</code>, <code>car</code>,...)</li> <li>dest_id: str = the id of the destination Hub</li> <li>metrics: EdgeMetadata = the edge object that stores the metrics for this connection</li> </ul>"},{"location":"graph/#getting-the-edge-metrics","title":"getting the edge metrics","text":"<p>Get the edgeMetadata from this Hub to another, with a given transport mode</p> <pre><code>def getMetrics(\n    self, \n    mode: str, \n    dest_id: str\n)-&gt; EdgeMetadata:\n</code></pre>"},{"location":"graph/#args_9","title":"args","text":"<ul> <li>mode: str = the mode of transport along the edge</li> <li>dest_id: str = the id of the destination Hub</li> </ul> <p>returns: the edgeMetadata or None if this edge doesn't exist</p>"},{"location":"graph/#-_2","title":"---","text":""},{"location":"graph/#edgemetadata","title":"EdgeMetadata","text":"<p>These objects store data about one edge such as the <code>transport mode</code> and metrics like <code>distance</code> etc.</p> <pre><code>def __init__(\n    self, \n    transportMode: str = None, \n    **metrics):\n</code></pre>"},{"location":"graph/#args_10","title":"args","text":"<ul> <li>transportMode: str = the transpot mode across this edge</li> <li>**metrics: dict = a dictionary of edge metrics like <code>distance</code>, <code>time</code> etc</li> </ul>"},{"location":"graph/#example_7","title":"example","text":"<p>create data for an edge that is traversed via <code>plane</code>, has a <code>distance</code> of <code>100.0</code> and <code>cost</code> of <code>250.0</code></p> <pre><code>edgeData = EdgeMetadata(\n    transportMode = 'plane',\n    **{'distance': 100.0, 'cost': '250.0'}\n)\n</code></pre>"},{"location":"graph/#get-a-specific-metric","title":"get a specific metric","text":"<pre><code>def getMetric(\n    self,\n    metric: OptimizationMetric | str\n):\n</code></pre>"},{"location":"graph/#args_11","title":"args","text":"<ul> <li>metric: str = the name of the metric you want to retrieve</li> </ul>"},{"location":"graph/#-_3","title":"---","text":""},{"location":"graph/#route","title":"Route","text":"<p>A dataclass to store all route related data; like Hubs and edges.</p>"},{"location":"graph/#fields_1","title":"fields","text":"<pre><code>path: list[tuple[str, str]]\ntotalMetrics: EdgeMetadata\noptimizedMetric: OptimizationMetric\n</code></pre>"},{"location":"graph/#properties","title":"properties","text":"<pre><code>@property\n    def flatPath(\n        self, \n        toStr=True):\n</code></pre> <p>By calling <code>route.flatPath</code> you will get the string representation of the route </p>"},{"location":"graph/#example-output","title":"example output","text":"<p>NOTE: this is a verbose route from <code>-1.680000, 29.258334</code> to <code>3.490000, 35.840000</code>, connected through airports with data from open flights</p> <pre><code>Start: GOM\n        Edge: (transportMode=plane, metrics={'distance': 85.9251874180552})\n-&gt; BKY\n        Edge: (transportMode=drive, metrics={'distance': np.float32(20.288797)})\n-&gt; KME\n        Edge: (transportMode=plane, metrics={'distance': 147.44185301830063})\n-&gt; KGL\n        Edge: (transportMode=plane, metrics={'distance': 757.9567739118678})\n-&gt; NBO\n        Edge: (transportMode=plane, metrics={'distance': 515.1466233682448})\n-&gt; LOK\n</code></pre>"},{"location":"graph/#route-to-graph","title":"Route To Graph","text":"<pre><code>def asGraph(self, graph):\n</code></pre>"},{"location":"graph/#args_12","title":"args:","text":"<ul> <li>graph: RouteGraph = The graph instance that created this route</li> </ul>"},{"location":"graph/#returns","title":"returns:","text":"<ul> <li>RouteGraph = a graph with only the nodes from the route</li> </ul> <p>NOTES if the given graph is missing some hubs from the route the created graph will skip the missing hubs and include new edges to connect the present hubs. (The new edges will only include the <code>distance</code> metric, which is calculated by the passed graph's distance function)</p>"},{"location":"graph/#filter","title":"Filter","text":"<p>The <code>Filter</code> class is an abstract class you can implement to add custom filter to you searches</p>"},{"location":"graph/#example_8","title":"example","text":"<pre><code>class ExampleFilter(Filter):\n\n    def __init__(\n        self, \n        forbiddenHubs: list[str], \n        filterVal: str | float\n    ):\n        self.forbiddenHubs = forbiddenHubs\n        self.filterVal = filterVal\n\n    def filterHub(self, hub: Hub) -&gt; bool:\n        return hub.id not in self.forbiddenHubs\n\n    def filterEdge(self, edge: EdgeMetadata) -&gt; bool:\n        return edge.getMetric('distance') &lt; 3 and edge.getMetric('yourCustomMetric') != self.filterVal\n</code></pre> <p>This <code>ExampleFilter</code> will remove all hubs with Ids in the forbidden hubs list and ignore all edges where: $distance &gt; 3 \\lor customMetric = filterVal $</p> <p>To make your own <code>Filter</code> just implement the <code>__init__</code>, <code>filterHUb</code> &amp; <code>filterEdge</code> functions and pass an object to the search (custom_filter = your flter object)</p> <p>Tipp: if you want to only add a filter for either Hubs or Edges set the function that shouldn't filter to return <code>True</code></p> <p>example</p> <pre><code>def filterHub(self, hub: Hub) -&gt; bool:\n    return True\n</code></pre> <p>will let any hub pass through the filter</p>"},{"location":"installation/","title":"Installation Guide","text":"<p>HOME</p>"},{"location":"installation/#installation-guide","title":"Installation Guide","text":""},{"location":"installation/#step-1","title":"Step 1","text":"<p>First check if your data comes with precomputed distances and if you are going to want to use the default driving connections when building your graph. Depending on your choices you will need to install the library with torch. To see what your use case requires check the table below and copy the command.</p> data has distances use driving edges planning to use build-in Haversine distance installation mode YES YES / <code>pip install multimodalrouter[torch]</code> YES NO / <code>pip install multimodalrouter[torch]</code> NO YES / <code>pip install multimodalrouter[torch]</code> NO NO NO <code>pip install multimodalrouter</code> / / YES <code>pip install multimodalrouter[torch]</code> <p>Tip: if unsure whether you will need torch or not, install without it first and install torch later if necessary</p>"},{"location":"installation/#step-2","title":"Step 2","text":"<p>RUN your command from the root of this project</p>"},{"location":"installation/#step-3","title":"Step 3","text":"<p>The library should now be installed to check you can test with this:</p> <pre><code>python -c \"import multimodalrouter; print(dir(multimodalrouter))\"\n</code></pre> <p>The result should look similar to this</p> <pre><code>[\n'EdgeMetadata', \n'Hub', \n'OptimizationMetric', \n'Route', \n'RouteGraph', \n'VerboseRoute', \n'...', \n'preprocessor', \n'utils'\n]\n</code></pre>"},{"location":"utils/","title":"Utils","text":"<p>HOME</p>"},{"location":"visualization/","title":"Visualization","text":"<p>HOME</p>"},{"location":"visualization/#graph-plotting","title":"Graph Plotting","text":"<p>Using the build-in graph plotting tool you can plotly plot any graph in <code>2D</code> or <code>3D</code>, while defining transformations for your coordiante space or even path curvature etc.</p>"},{"location":"visualization/#graphdisplay","title":"GraphDisplay","text":"<pre><code>def __init__(\n    self,\n    graph: RouteGraph,\n    name: str = \"Graph\",\n    iconSize: int = 10\n) -&gt; None:\n</code></pre>"},{"location":"visualization/#args","title":"args:","text":"<pre><code>- graph: RouteDisplay = the graph instance you want to plot\n- name: str = (not in use at the moment)\n- iconSize: int = the size of the nodes in the plot\n</code></pre>"},{"location":"visualization/#example","title":"example","text":"<pre><code>gd = GraphDisplay(myGraphInstance)\n</code></pre> <p>flight path CODE example on sphere</p>"},{"location":"visualization/#display","title":"display()","text":"<p>The display function will collect data from your Graph and create a plotly plot from it.</p> <pre><code>def display(\n    self,\n    nodeTransform=None,\n    edgeTransform=None,\n    displayEarth=False\n):\n</code></pre>"},{"location":"visualization/#args_1","title":"args:","text":"<ul> <li>nodeTransform: function = a transformation function that transformes all node coordinates</li> <li>edgeTransform: funstion = a function that transformes all your edges</li> <li>displayEarth: bool = if True -&gt; will display a sphere that (roughly) matches earth</li> </ul>"},{"location":"visualization/#example_1","title":"example:","text":"<p>this call will create the plot for your graph while mapping all coords onto the surface of the earth</p> <pre><code>gd.display(\n    nodeTransform = gd.degreesToCartesian3D,\n    displayEarth: True\n)\n</code></pre>"},{"location":"visualization/#transformations","title":"transformations","text":""},{"location":"visualization/#base-function-style","title":"base function style","text":"<p>IF you want to implement your own transformation function note that the call must adhere to the following parameters:</p> <pre><code>def customNodeTrandsform(coords: list[list[float]]):\n    return list[list[float]]\n\ndef customEdgeTransform(start: list[list[float]], end: list[list[float]]):\n    return list[list[list[float]]]\n</code></pre>"},{"location":"visualization/#args_2","title":"args","text":"<ul> <li>coords: list[list[float]] = a nested list of coordinates for all nodes</li> <li>start: list[list[float]] = a nested list of all start coordinates</li> <li>end: list[list[float]] = a nested list of all end coordinates</li> </ul>"},{"location":"visualization/#returns","title":"returns:","text":"<ul> <li>list[list[float]] = a list of all transformed node coordinates</li> <li>list[list[list[float]]] = a list of curves whare each curve / edge can have n points defining it </li> </ul>"},{"location":"visualization/#build-in-node-transforms","title":"build-in Node Transforms:","text":""},{"location":"visualization/#degreestocartesian3d","title":"degreesToCartesian3D","text":"<pre><code>@staticmethod\n    def degreesToCartesian3D(coords):\n</code></pre> <p>This function maps any valid <code>2D</code> coordinates (best if in degrees) to spherical coords on the surface of earth</p>"},{"location":"visualization/#build-in-edge-transformations","title":"build-in Edge Transformations","text":"<pre><code>@staticmethod\n    def curvedEdges(start, end, R=6371.0, H=0.05, n=20):\n</code></pre> <p>curves edges for coordinates on spheres (here earth) so that the edges curve along the spherical surface with a curvature that places the midpoint of the curve at H \\dot R above the surface. (great for displaying flights). </p> <p>If torch is installed this will use great-circle distance for the curves</p> <p>Note if torch is not installed this will fall back to using <code>math</code> with quadratic bezier curves -&gt; some curves may end up inside the sphere to bezier inaccuracy </p>"}]}